#!/usr/bin/env lua

-- EH specific functions for fimbul
--

local pretty = require('pl.pretty')
local std = require('std')

local util = require('fimbul.util')
local repository = require('fimbul.repository')

local optparser = std.optparse(
[[
fimbul-eh 0.1

Part of the fimbul project. All rights reserved.

Usage: fimbul-eh [options] [command]

The fimbul-eh command helps with Endless Horizons specific tasks, such as
calculating the cost of backgrounds and so forth.

Options:
  -r --repository   Alternate path to repository to use.
  -v --verbose      Verbose output.

Commands:
  background      Calculate cost of background. Takes one parameter: The
                  background to calculate for. If not given will calculate
                  all backgrounds.

Please report bugs to https://github.com/n0la/fimbul.
]])

local r
local repo

function print_background(b)
   print('Name: ' .. b:name())
   print('Cost: ' .. b:cost())
   print('Actual Cost: ' .. b:actual_cost())

   print("Abilities:")
   for _, a in ipairs(b:abilities()) do
      print('  ' .. a:name() .. ': ' .. a:rank() .. "\n")
   end

   print("Skills:")
   for _, s in ipairs(b:skills()) do
      print(' ' .. s:name() .. ': ' .. s:rank())
   end
end

function eh_background()
   local background = util.shift(_G.arg)
   local b = {}

   if background == nil then
      -- Do all
      b = r.eh.backgrounds
   else
      -- Do one specific
      b = r:find(r.eh.backgrounds, background)
   end

   -- Print background
   for _, i in ipairs(b) do
      local bg = r:spawn(i)
      print_background(bg)
   end
end

local commands = {
   ['background'] = {handler = eh_background}
}

if arg[1] == nil or not util.containskey(commands, arg[1]) then
   optparser:help()
   os.exit(0)
end

local cmd = arg[1]
table.remove(arg, 1)
_G.arg, _G.opts = optparser:parse(_G.arg)

if opts['repository'] ~= nil then
   repo = opts['repository']
else
   repo = '.'
end

ok, r = pcall(repository.new, repository, repo)
if not ok then
   io.stderr:write(r .. "\n")
   os.exit(3)
end

local ok, ret = pcall(commands[cmd].handler)
if ok then
   os.exit(ret or 0)
else
   io.stderr:write(ret .. "\n")
   os.exit(3)
end
